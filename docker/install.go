package docker

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path"
	"regexp"

	g "github.com/stellaraf/rmon-node-setup/globals"
	util "github.com/stellaraf/rmon-node-setup/util"
)

func getArch() (arch string) {
	cmd := exec.Command("dpkg", "--print-architecture")
	output, err := cmd.Output()
	util.Check("Error getting CPU architecture: ", err)
	return util.AsString(output)
}

func getRelease() (osID string, release string) {
	osPattern := regexp.MustCompile(`^ID=(\w+)$`)
	releasePattern := regexp.MustCompile(`^VERSION_CODENAME=(\w+)$`)
	file, err := os.Open("/etc/os-release")
	util.Check("Error reading OS info from /etc/os-release: ", err)
	defer file.Close()
	scanner := bufio.NewScanner(file)
	osID = ""
	release = ""
	for scanner.Scan() {
		line := scanner.Text()
		osMatch := osPattern.FindStringSubmatch(line)
		relMatch := releasePattern.FindStringSubmatch(line)
		if len(osMatch) > 1 {
			osID = osMatch[1]
		}
		if len(relMatch) > 1 {
			release = relMatch[1]
		}
	}
	if osID == "" {
		util.Critical("No OS was detected")
		os.Exit(1)
	}
	if release == "" {
		util.Critical("No release was detected")
		os.Exit(1)
	}

	util.Info("OS/Release: %s/%s", osID, release)
	return osID, release
}

func aptSetup() {
	arch := getArch()
	osID, release := getRelease()

	repoTmpl := "deb [arch=%s] https://download.docker.com/linux/%s %s stable"
	repo := fmt.Sprintf(repoTmpl, arch, osID, release)

	filename := "/etc/apt/sources.list.d/docker.list"
	file, err := os.Create(filename)
	util.Check("Error creating docker APT source file at %s: ", err, filename)
	defer file.Close()

	_, err = file.WriteString("# This file is automatically generated by rmon-node-setup. Do not override.\n" + repo + "\n")
	util.Check("Error writing APT repo source to file %s: ", err, filename)

	util.Success("Added %s to APT sources", repo)
}

func composeInstalled() (i bool) {
	cmd := exec.Command("python3", "-m", "compose")
	_, err := cmd.CombinedOutput()
	if err != nil {
		i = false
	} else {
		i = true
	}
	return
}

// Install installs docker.
func Install() {
	util.Info("Installing docker...")
	aptSetup()
	out, err := exec.Command("apt-get", "update").CombinedOutput()
	util.Check("Error updating APT:\n%s", err, util.AsString(out))

	install := exec.Command("apt-get", "install", "-y", "docker-ce", "docker-ce-cli", "containerd.io")
	out, err = install.CombinedOutput()
	util.Check("Error installing Docker:\n%s", err, util.AsString(out))
}

// InstallCompose installs docker-compose if it is not already intstalled.
func InstallCompose() {
	installed := composeInstalled()

	if !installed {
		util.Info("Docker Compose is not installed. Installing...")
		out, err := exec.Command("pip3", "install", "docker-compose").CombinedOutput()
		util.Check("Error installing Docker Compose:\n%s", err, util.AsString(out))
	}
}

// Scaffold creates a directory in the docker config directory for docker-compose files.
func Scaffold(hostname string) {
	dir := "/etc/docker/compose"

	srcDir := path.Join(fmt.Sprintf(g.HomeDir, g.LocalUser), hostname)

	cmpFileSrc := path.Join(srcDir, "mp-compose.yaml")
	cmpFileDst := path.Join(dir, "appneta-cmp.yaml")

	util.CopyFile(cmpFileSrc, cmpFileDst)
	util.Success("Copied %s to %s", cmpFileSrc, cmpFileDst)

	envFileSrc := path.Join(srcDir, ".env")
	envFileDst := path.Join(dir, ".env")

	util.CopyFile(envFileSrc, envFileDst)
	util.Success("Copied %s to %s", envFileSrc, envFileDst)
}
