package util

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"os/user"
	"path"
	"runtime"
	"strconv"
	"strings"
	"syscall"
)

// RunAs runs a function with lower privileges.
func RunAs(u string, f func()) func() {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	uid := 0
	gid := 0
	errorMsg := "Error while dropping privileges: "
	userInfo, err := user.Lookup(u)
	Check(errorMsg, err)

	uidC, errU := strconv.Atoi(userInfo.Uid)
	Check(errorMsg, errU)
	uid = uidC

	gidC, errG := strconv.Atoi(userInfo.Gid)
	Check(errorMsg, errG)
	gid = gidC

	_, _, gErr := syscall.Syscall(syscall.SYS_SETGID, uintptr(gid), 0, 0)
	if gErr != 0 {
		Check(errorMsg, gErr)

	}

	_, _, uErr := syscall.Syscall(syscall.SYS_SETUID, uintptr(uid), 0, 0)
	if uErr != 0 {
		Check(errorMsg, uErr)
	}

	return f
}

// IsRoot determines if this package is being run as root.
func IsRoot() (r bool) {
	r = syscall.Getuid() == 0
	return
}

// ResetRoot sets the running user back to 0.
func ResetRoot() {

	_, _, gErr := syscall.Syscall(syscall.SYS_SETGID, 0, 0, 0)

	if gErr != 0 {
		Check("Error while escalating privileges", gErr)
	}

	_, _, uErr := syscall.Syscall(syscall.SYS_SETUID, 0, 0, 0)
	if uErr != 0 {
		Check("Error while escalating privileges", uErr)
	}

}

// GetUserGroups gets the current list of groups for which a user is a member.
func GetUserGroups(user string) (groups []string) {
	out, err := exec.Command("groups", user).CombinedOutput()
	Check("Error reading groups: for user %s: \n%s", err, user, AsString(out))
	parts := strings.Split(AsString(out), " : ")
	groups = strings.Split(parts[1], " ")
	return
}

// AddToSudoers adds a user to the sudoers file.
func AddToSudoers(user string) (result bool) {
	sudoers := `# This file is autogenerated. Do not override.
%s    ALL=(ALL:ALL) ALL
`
	result = false
	line := []byte(fmt.Sprintf(sudoers, user))
	filename := path.Join("/etc/sudoers.d", user)
	if !FileExists(filename) {
		file, err := os.Create(filename)
		Check("Error creating sudoers file %s", err, filename)
		file.Close()
	}
	content, err := ioutil.ReadFile(filename)
	Check("Error reading sudoers file %s", err, filename)
	if bytes.Equal(line, content) {
		result = true
	} else {
		file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY|os.O_TRUNC, os.ModeAppend)
		Check("Error opening sudoers file %s", err, filename)
		_, err = file.Write(line)
		Check("Error writing to sudoers file %s. Tried to write:\n%v", err, filename, content)
		Success("Added %s to sudoers", user)
		AddToSudoers(user)
	}
	return
}

// AllGroups gets a list of all groups on the system.
func AllGroups() (g []string) {
	file, err := os.Open("/etc/group")
	Check("Error getting current groups: ", err)
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		group := strings.Split(line, ":")[0]
		g = append(g, group)
	}
	return
}

// UserCommand runs a command with environment variables set for the user.
func UserCommand(base string, args ...string) ([]byte, error) {
	uid := os.Getuid()
	xdg := fmt.Sprintf("XDG_RUNTIME_DIR=/run/user/%s", strconv.Itoa(uid))
	cmd := exec.Command(base, args...)
	cmd.Env = append(os.Environ(), xdg)
	return cmd.CombinedOutput()
}

// UserToGroup adds a user to a group that is assumed to exist.
func UserToGroup(user string, group string) {
	addUserToGroup := exec.Command("usermod", "-aG", group, user)
	out, err := addUserToGroup.CombinedOutput()
	Check("Error adding user %s to group %s:\n%s", err, user, group, AsString(out))
	Success("Added user %s to group %s", user, group)
}

// NewGroup adds a new group.
func NewGroup(group string) {
	Info("Adding group %s...", group)
	addGroup := exec.Command("groupadd", group)
	out, err := addGroup.CombinedOutput()
	Check("Error creating group %s:\n%s", err, group, AsString(out))
	Success("Created group %s", group)
}

// CurrentUser gets the current user object.
func CurrentUser() *user.User {
	user, err := user.Current()
	Check("Error getting current user", err)
	return user
}
